# React and TypeScript Workshop

Code from attending Steve Kinney's `React and Typescript Workshop`Â at FrontEnd Masters.

Since there were many examples, I placed only the ones that were used to do exercises/challenges and placed them in the `used-projects` folder.

## Original Repo

Can be found [here](https://github.com/stevekinney/react-and-typescript-projects).

## Workshop Website

[React and Typescript Workshop](https://frontendmasters.com/workshops/react-typescript/).
<br>

## Workshop Content

1. ### The Fundamentals
   1. The Very Basics
   2. Refactoring from PropTypes
   3. Commonly-Used Props
   4. Typing Children
   5. Typing Children (Solution)
   6. Typing Styling
2. ### Interacting with Components
   1. useState Hook
   2. Setting State without a Default Value
   3. useEffect
   4. Typing Class-based Components
   5. Forms and Events (Exercise)
   6. Exercise: Dog Facts
3. ### Working with Reducers
   1. Typing Reducers
   2. Reducers (Exercise)
   3. Reducers (Solution)
4. ### Color and Context
   1. Prologue: Passing Dispatch as a Props
   2. The Context API
   3. The Context API with State Management
   4. Refactoring the Color Inputs
5. ### Just Enough TypeScript
   1. Working with Generics
   2. A Tour of Utility Types in React
   3. Refactoring the Character Cards with Utility Types
   4. Utility Types (Exercise)
   5. Utility Types (Solution)
   6. Type Template Literals
   7. Type Template Literals: Refactoring Our Color Adjustment Actions
6. ### Higher Order Components
   1. Higher Order Components with TypeScript
   2. Higher Order Components with TypeScript (Exercise)
   3. Higher Order Components (Solution)
7. ### Advanced Component Patterns
   1. Limiting Props a Component Can Take Based on Other Props
   2. Polymorphic Components with TypeScript
   3. Polymorphic Components (Exercise)
   4. Polymorphic Components (Solution)
   5. Function Overloads
   6. Demanding Props Based on Other Props
   7. Solving for Context API Edge Cases
8. ### Appendix
   1. Migrating From JavaScript
   2. Types Versus Interfaces
